(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.postdata = factory());
}(this, (function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var hbhbrowser_min = createCommonjsModule(function (module, exports) {
	!function(e,i){module.exports=i();}(commonjsGlobal,function(){return function e(i){if("undefined"!=typeof window)i=i?i.toLowerCase():navigator.userAgent.toLowerCase();else {if(!i)return {parse:e};i=i.toLowerCase();}return {isMobile:/(andriod|iphone|ipad|ipod|blackberry|opera mini|webos|iemobile)/.test(i),isAndroid:-1<i.indexOf("android"),isIOS:/(ipad|ipod|iphone)/.test(i),isWeixin:-1<i.indexOf("micromessenger"),isQQ:-1<i.indexOf("mqqbrowser")||-1<i.indexOf("qq/"),isApp:/<<a=(hunbasha_ios|yingbasha_ios|hunbasha_android|yingbasha_android)/.test(i),isBaiduApp:-1<i.indexOf("baiduboxapp"),isWeibo:-1<i.indexOf("weibo"),parse:e}}()});
	});

	var js_cookie = createCommonjsModule(function (module, exports) {
	(function (factory) {
		var registeredInModuleLoader;
		{
			module.exports = factory();
			registeredInModuleLoader = true;
		}
		if (!registeredInModuleLoader) {
			var OldCookies = window.Cookies;
			var api = window.Cookies = factory();
			api.noConflict = function () {
				window.Cookies = OldCookies;
				return api;
			};
		}
	}(function () {
		function extend () {
			var i = 0;
			var result = {};
			for (; i < arguments.length; i++) {
				var attributes = arguments[ i ];
				for (var key in attributes) {
					result[key] = attributes[key];
				}
			}
			return result;
		}

		function decode (s) {
			return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
		}

		function init (converter) {
			function api() {}

			function set (key, value, attributes) {
				if (typeof document === 'undefined') {
					return;
				}

				attributes = extend({
					path: '/'
				}, api.defaults, attributes);

				if (typeof attributes.expires === 'number') {
					attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);
				}

				// We're using "expires" because "max-age" is not supported by IE
				attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';

				try {
					var result = JSON.stringify(value);
					if (/^[\{\[]/.test(result)) {
						value = result;
					}
				} catch (e) {}

				value = converter.write ?
					converter.write(value, key) :
					encodeURIComponent(String(value))
						.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);

				key = encodeURIComponent(String(key))
					.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)
					.replace(/[\(\)]/g, escape);

				var stringifiedAttributes = '';
				for (var attributeName in attributes) {
					if (!attributes[attributeName]) {
						continue;
					}
					stringifiedAttributes += '; ' + attributeName;
					if (attributes[attributeName] === true) {
						continue;
					}

					// Considers RFC 6265 section 5.2:
					// ...
					// 3.  If the remaining unparsed-attributes contains a %x3B (";")
					//     character:
					// Consume the characters of the unparsed-attributes up to,
					// not including, the first %x3B (";") character.
					// ...
					stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
				}

				return (document.cookie = key + '=' + value + stringifiedAttributes);
			}

			function get (key, json) {
				if (typeof document === 'undefined') {
					return;
				}

				var jar = {};
				// To prevent the for loop in the first place assign an empty array
				// in case there are no cookies at all.
				var cookies = document.cookie ? document.cookie.split('; ') : [];
				var i = 0;

				for (; i < cookies.length; i++) {
					var parts = cookies[i].split('=');
					var cookie = parts.slice(1).join('=');

					if (!json && cookie.charAt(0) === '"') {
						cookie = cookie.slice(1, -1);
					}

					try {
						var name = decode(parts[0]);
						cookie = (converter.read || converter)(cookie, name) ||
							decode(cookie);

						if (json) {
							try {
								cookie = JSON.parse(cookie);
							} catch (e) {}
						}

						jar[name] = cookie;

						if (key === name) {
							break;
						}
					} catch (e) {}
				}

				return key ? jar[key] : jar;
			}

			api.set = set;
			api.get = function (key) {
				return get(key, false /* read as raw */);
			};
			api.getJSON = function (key) {
				return get(key, true /* read as json */);
			};
			api.remove = function (key, attributes) {
				set(key, '', extend(attributes, {
					expires: -1
				}));
			};

			api.defaults = {};

			api.withConverter = init;

			return api;
		}

		return init(function () {});
	}));
	});

	var postwebUrl = 'https://open.jiehun.com.cn/user/sdk/post-web-data'; //接口地址
	var DOMAIN = '.jiehun.com.cn'; //domain
	var HOST = window.location.host;
	if (HOST.indexOf('test') !== -1 || HOST.indexOf('localhost') !== -1) {
	    postwebUrl = 'http://open.test.jiehun.com.cn/user/sdk/post-web-data';
	} else if (HOST.indexOf('beta') !== -1) {
	    postwebUrl = 'https://open-beta.jiehun.com.cn/user/sdk/post-web-data';
	} else {
	    postwebUrl = 'https://open.jiehun.com.cn/user/sdk/post-web-data';
	}

	//默认根据当前域名自动判断domain,如都不匹配则默认.jiehun.com.cn
	var domainList = ['.jiehun.com.cn', '.yingbasha.com', '.zghbh.com'];
	domainList.map(function (index) {
	    if (HOST.indexOf(index) > -1) {
	        DOMAIN = index;
	    }
	});

	var ACTIONTYPE = ['tap', 'view', 'show', 'logic']; //当前使用中的事件上报类型


	var config = {
	    version: '1.4.0',
	    posturl: postwebUrl,
	    domain: DOMAIN,
	    ACTIONTYPE: ACTIONTYPE
	};

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	  return typeof obj;
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	};

	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

	var createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

	var toConsumableArray = function (arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

	    return arr2;
	  } else {
	    return Array.from(arr);
	  }
	};

	/** 生成随机的id */
	var generateUUID = function generateUUID() {
	  var d = new Date().getTime();
	  var uuid = 'xxxxxxxx-xxxx-yxxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	    var r = (d + Math.random() * 16) % 16 | 0;
	    d = Math.floor(d / 16);
	    return (c === 'x' ? r : r & 0x3 | 0x8).toString(16);
	  });
	  return uuid;
	};

	/* 
	  生成随机的4位数
	*/
	var mathRandom = function mathRandom() {
	  return (Math.random() * 10000000).toString(16).substr(0, 4);
	};

	/** 获取cookie中的信息 */
	var getHead = function getHead(params, cookielist) {
	  if (cookielist) {
	    var cookieArr = cookielist.split(';');
	    for (var i in cookieArr) {
	      var cookie = cookieArr[i].replace(/(^\s*)|(\s*$)/g, '');
	      var index = cookie.indexOf('=');
	      var name = cookie.substr(0, index);
	      var value = decodeURIComponent(cookie.substr(index + 1));
	      switch (name) {
	        case 'Authorization':
	          if (value) {
	            if (/^dmp/.test(value)) {
	              params.authorization = value;
	            } else {
	              params.authorization = 'dmp ' + value;
	            }
	          }          break;
	        case 'jhu':
	          if (value) {
	            if (/^dmp/.test(value)) {
	              params.authorization = value;
	            } else {
	              params.authorization = 'dmp ' + value;
	              // todu
	            }
	          }
	          break;
	        case 'jid':
	          params.jid = value;
	          break;
	        case 'client-id':
	          if (hbhbrowser_min.isApp) {
	            //在app中打开，client-id以app提供的为准
	            params.client_id = value;
	          } else {
	            params.jid = value;
	          }          break;
	        case 'app-channel':
	          params.app_channel = value;
	          break;
	        case 'app-version':
	          params.app_version = value;
	          break;
	        case 'device-id':
	          params.device_id = value;
	          break;
	        case 'view-id':
	          params.view_id = value;
	          break;
	        case 'lat':
	          params.lat = value;
	          break;
	        case 'lng':
	          params.lng = value;
	          break;
	        // todo
	      }
	    }
	  }
	  /**
	    * 判断有没有jid 如果没有的话生成并且保存在cookie中
	    */
	  if (!params.jid || params.jid === 'undefined') {
	    params.jid = generateUUID().split('-').join('');
	    js_cookie.set('jid', params.jid, { expires: 1, path: '/', domain: params.domain });
	  }
	  if (!params.app_version) {
	    params.app_version = config.version;
	  }
	  return params;
	};

	/**
	 * 
	 * @param  name 参数name
	 */
	var getUrlParam = function getUrlParam(name) {
	  var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)"); // 构造一个含有目标参数的正则表达式对象
	  var r = window.location.search.substr(1).match(reg); // 匹配目标参数
	  if (r != null) return unescape(r[2]);
	  return null; // 返回参数值
	};

	/**
	 * 封装简易的ajax
	 * @param type 请求方式
	 * @param url 请求接口地址
	 * @param async 同步／异步
	 * @param data 请求数据
	 * @param dataType 数据格式
	 * @param headers 自定义请求头
	 * @param success 请求成功
	 * @param error 请求失败
	 */
	var hAjax = function hAjax() {
	  for (var _len = arguments.length, theArgs = Array(_len), _key = 0; _key < _len; _key++) {
	    theArgs[_key] = arguments[_key];
	  }

	  var ajaxData = {
	    type: (theArgs[0].type || 'POST').toUpperCase(),
	    url: theArgs[0].url || '',
	    async: theArgs[0].async || 'true',
	    data: theArgs[0].data || null,
	    dataType: theArgs[0].dataType || 'json',
	    headers: theArgs[0].headers || {},
	    beforeSend: theArgs[0].beforeSend || function () {},
	    success: theArgs[0].success || function () {},
	    error: theArgs[0].error || function () {},
	    callback_time: theArgs[0].callback_time || false,
	    callback_timeout: theArgs[0].callback_timeout || 1000
	  };
	  var createxmlHttpRequest = function createxmlHttpRequest() {
	    if (window.ActiveXObject) {
	      return new ActiveXObject('Microsoft.XMLHTTP');
	    } else if (window.XMLHttpRequest) {
	      return new XMLHttpRequest();
	    }
	  };
	  ajaxData.beforeSend();
	  var xhr = createxmlHttpRequest();
	  xhr.responseType = ajaxData.dataType;
	  xhr.open(ajaxData.type, ajaxData.url, ajaxData.async);
	  if (ajaxData.callback_time) {
	    xhr.timeout = ajaxData.callback_timeout || 0;
	  }
	  xhr.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');
	  xhr.setRequestHeader('Accept', 'application/json, text/plain, */*');
	  for (var i in ajaxData.headers) {
	    xhr.setRequestHeader(i, ajaxData.headers[i]);
	  }
	  xhr.send(JSON.stringify(ajaxData.data));
	  xhr.onreadystatechange = function () {
	    if (xhr.readyState === 4) {
	      if (xhr.status === 200) {
	        ajaxData.success(xhr.response);
	      } else {
	        ajaxData.error();
	      }
	    }
	  };
	};

	/**
	 * js实现时间委托
	 * @param interfaceEle 父级元素
	 * @param selector 点击元素
	 * @param type 事件类型
	 * @param fn 回调函数
	 */
	var delegateEvent = function delegateEvent(interfaceEle, selector, type, fn) {
	  var eventfn = function eventfn(e) {
	    var element = e || window.event;
	    var target = element.target || element.srcElement;
	    isParentNode(target, selector, fn, element);
	  };
	  if (interfaceEle.addEventListener) {
	    interfaceEle.addEventListener(type, eventfn);
	  } else {
	    interfaceEle.attachEvent('on' + type, eventfn);
	  }
	  // 如果点击的是目标元素的子元素，则往上冒泡寻找
	  var isParentNode = function isParentNode(target, selector, fn, e) {
	    if (matchSelector(target, selector)) {
	      if (fn) {
	        fn.call(target, e);
	      }
	    } else {
	      if (target.parentNode) {
	        target = target.parentNode;
	        isParentNode(target, selector, fn, e);
	      }
	    }
	  };
	  // 判断事件的作用目标是否与选择器匹配
	  var matchSelector = function matchSelector(ele, selector) {
	    if (ele === null) return;
	    if (selector.charAt(0) === '#') {
	      return ele.id === selector.slice(1);
	    }    if (selector.charAt(0) === '.') {
	      return (' ' + ele.className + ' ').indexOf(' ' + selector.slice(1) + ' ') !== -1;
	    }
	  };
	};

	/**
	 * debug 测试环境debug模式
	 * @param res 事件上报接口返回参数
	 * @param body|header 上报的参数
	 * @param type 区分事件类型
	 */

	var debug = function debug(body, type) {
	  var TYPES = ['actionName', 'actionType', 'actionParm', 'timeOnPage', 'pvId'];
	  var journalinfoBody = ''; // body数据
	  for (var key in body) {
	    if (TYPES.includes(key)) {
	      var info = '[' + key + ']' + ' ==== ' + body[key];
	      journalinfoBody += info + '\n';
	    }
	  }
	  console.info('%c' + type, 'color:red;font-size:16px');
	  console.info(journalinfoBody);
	};

	/**
	 * 获取地址栏参数
	 * @param name 参数名称
	 */
	var getQueryString = function getQueryString(name) {
	  var reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)');
	  var r = window.location.search.substr(1).match(reg);
	  if (r !== null) {
	    return unescape(r[2]);
	  } else {
	    return null;
	  }
	};

	var actionStringify = function actionStringify(arr, action) {
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = arr[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var key = _step.value;

	      if (action[key]) {
	        if (action[key].constructor === Object) {
	          action[key] = JSON.stringify(action[key]);
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }

	  return action;
	};
	/**
	 * 格式化json 
	 * 此函数的作用
	 * 1、检测actionParm 格式是否是json
	 * 2、如果actionParm 不是正确的json格式字符串,则利用正则进行修改。
	 * @param json 传入的数据 
	 */
	var formatJson = function formatJson(json) {
	  var KEYS = ['actionValue', 'actionParm'];
	  var jsonTemp = null;
	  var actionJsontemp = null;
	  var actionData = null;
	  if (json.constructor === Object) {
	    // {
	    //   actionName:"test",
	    //   actionParm:{
	    //     url:"https://m.jiehun.com.cn"
	    //   }
	    // }
	    actionData = json;
	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;

	    try {
	      for (var _iterator2 = KEYS[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	        var key = _step2.value;

	        if (actionData[key]) {
	          if (actionData[key].constructor === Object) {
	            actionData[key] = JSON.stringify(actionData[key]);
	          } else if (actionData[key].constructor === String) {
	            jsonTemp = actionData[key].replace(/([\w]+[^https|http|ciw|(".*")|('.*')])(:)/g, "\"$1\"$2");
	            actionJsontemp = jsonTemp.replace(/'/g, "\"");
	            actionData[key] = actionJsontemp;
	          } else {
	            actionData[key] = "{}";
	          }
	        }
	      }
	    } catch (err) {
	      _didIteratorError2 = true;
	      _iteratorError2 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion2 && _iterator2.return) {
	          _iterator2.return();
	        }
	      } finally {
	        if (_didIteratorError2) {
	          throw _iteratorError2;
	        }
	      }
	    }
	  } else {
	    try {
	      //{"actionName":"test","actionPath":"https://m.jiehun.com.cn"}
	      actionData = JSON.parse(json);
	    } catch (e) {
	      jsonTemp = json.replace(/([\w]+[^https|http|ciw|(".*")|('.*')])(:)/g, "\"$1\"$2");
	      actionJsontemp = jsonTemp.replace(/'/g, "\"");
	      try {
	        //{actionName:"test",actionParm:{"url":"https://m.jiehun.com.cn"}}
	        actionData = JSON.parse(actionJsontemp);
	        actionData = actionStringify(KEYS, actionData);
	      } catch (e) {
	        //{actionName:"test",actionParm:"{"url":"https://m.jiehun.com.cn"}"}
	        var spliceJsontemp = actionJsontemp.replace(/("{)/g, "{").replace(/(}")/g, "}");
	        try {
	          actionData = JSON.parse(spliceJsontemp);
	          actionData = actionStringify(KEYS, actionData);
	        } catch (e) {
	          //{actionName:"test",actionValue:https://m.jiehun.com.cn}
	          var jsonactionJsontemp = actionJsontemp.replace(/(:)(((https?|ciw):\/\/(([a-zA-Z0-9_-])+(\.)?)*(:\d+)?(\/((\.)?(\?)?=?&?[a-zA-Z0-9_-](\?)?)*)*)|([\w]+))/g, "$1\"$2\"");
	          try {
	            actionData = JSON.parse(jsonactionJsontemp);
	            actionData = actionStringify(KEYS, actionData);
	          } catch (e) {
	            console.error('格式错误');
	          }
	        }
	      }
	    }
	  }
	  //针对事件上报和曝光统计做一个初步的校验，如果actionParm格式不是json，则会报出一个警告；
	  if (actionData.actionType !== 'page') {
	    if (actionData.actionParm && actionData.actionParm.constructor == String) {
	      var reg = RegExp(/{.*}/);
	      if (!actionData.actionParm.match(reg)) {
	        console.error('[注意警告] actionParm 格式应为JSON ');
	        actionData.actionParm = '{}';
	      }
	    }
	  }
	  return actionData;
	};

	/**
	 * //将对象中value为空的属性过滤掉
	 * @param {data} 原始对象 
	 */
	var isEmpty = function isEmpty(data) {
	  var action = Object.assign({}, data);
	  for (var i in action) {
	    if (!action[i]) {
	      delete action[i];
	    }
	  }
	  return action;
	};

	/** 
	* 设置 localStorage
	*  @param {key} 
	*  @param {value} 
	*/
	var setStorage = function setStorage(key, value) {
	  var values = null;
	  try {
	    values = JSON.stringify(value);
	  } catch (err) {
	    values = null;
	  }
	  window.localStorage.setItem(key, values);
	};

	/** 
	* 获取 localStorage
	*  @param {key} 
	*/
	var getStorage = function getStorage(key) {
	  var values = window.localStorage.getItem(key);
	  if (!values || values == 'null' || values == 'undefined') return null;
	  try {
	    values = JSON.parse(values);
	  } catch (err) {
	    values = null;
	  }
	  return values;
	};

	/** 
	* 删除 localStorage
	*  @param {key} 
	*/
	var removeStorage = function removeStorage(key) {
	  window.localStorage.removeItem(key);
	};

	/** 检查插入的数据是否为空或者对象 @param {data} 数据 */
	var checkType = function checkType(data) {
	  if (typeof data == "undefined" || (typeof data === 'undefined' ? 'undefined' : _typeof(data)) == "object") {
	    return true;
	  } else {
	    return false;
	  }
	};

	/**返回一个毫秒级的时间戳 */
	var nowtime = function nowtime() {
	  return new Date().getTime().toString();
	};

	//判断是否是object
	var isObject = function isObject(option) {
	  return typeof option !== 'undefined' && (typeof option === 'undefined' ? 'undefined' : _typeof(option)) == 'object' ? true : false;
	};

	var ua = window.navigator.userAgent;
	var domain = window.location;
	var appList = ['hunbasha_wap', 'yingbasha_wap', 'hunbasha_pc', 'yingbasha_pc', 'merchantcenter_pc', 'hunbasha_mp_invite_wap', 'jiabasha_mp_wap', 'hunbasha_mp_wap', 'hunbasha_bdmp_wap'];
	//app-key列表 除app特有的key

	var isWeixinMini = window.__wxjs_environment === 'miniprogram' || ua.indexOf('miniprogram') !== -1; // 小程序webview环境

	var appkey = function appkey(key) {
	  var browser = hbhbrowser_min.parse(ua);
	  var appkeyCookie = js_cookie.get('app-key'); // cookie中的app-key信息
	  var terminal = {
	    isApp: browser.isApp, //app
	    miniprogram: browser.isWeixin && isWeixinMini, //微信小程序
	    baiduboxapp: ua.indexOf('swan-baiduboxapp') !== -1, //百度小程序
	    host_jiehun: domain.host.indexOf('jiehun.com') !== -1, //结婚线
	    host_yingbasha: domain.host.indexOf('yingbasha.com') !== -1 //母婴线


	    //app环境
	  };if (terminal.isApp) {
	    if (appkeyCookie) {
	      return appkeyCookie;
	    } else {
	      return 'hunbasha_wap';
	    }
	  }

	  //微信/百度小程序环境
	  if (terminal.miniprogram || terminal.baiduboxapp) {
	    if (getQueryString('uappkey')) {
	      if (appList.indexOf(key) !== -1) {
	        return getQueryString('uappkey');
	      } else {
	        return 'hunbasha_wap';
	      }
	    } else {
	      return 'hunbasha_wap';
	    }
	  }

	  // 如果是普通浏览器环境
	  if (key) {
	    if (appList.indexOf(key) !== -1) {
	      return key;
	    } else {
	      if (terminal.host_jiehun) {
	        return 'hunbasha_wap';
	      } else if (terminal.host_yingbasha) {
	        return 'yingbasha_wap';
	      } else {
	        return 'hunbasha_wap';
	      }
	    }
	  } else {
	    if (terminal.host_jiehun) {
	      return 'hunbasha_wap';
	    } else if (terminal.host_yingbasha) {
	      return 'yingbasha_wap';
	    } else {
	      return 'hunbasha_wap';
	    }
	  }
	};

	/**
	 * city-id 城市id处理逻辑
	 *
	 * if(sessionStorage 中存在 city-id){
	 *      //todo 返回sessionStorage 中 city-id
	 * }else if(cookie 中存在 city-id){
	 *      //todo 返回cookie 中 city-id
	 * }else{
	 *      //todo 全国0
	 * }
	 */

	var cityid = function cityid() {
	  var sessionCityid = window.sessionStorage.getItem('city-id');
	  var cookieCityid = js_cookie.get('city-id');
	  var postCityid = '0';
	  var exp = /^(null)|(undefined)|'.*'|".*"$/;
	  var isCityid = new RegExp(exp);

	  if (sessionCityid && !isCityid.test(sessionCityid)) {
	    postCityid = sessionCityid;
	    window.sessionStorage.removeItem('city-id');
	  } else if (cookieCityid && !isCityid.test(cookieCityid)) {
	    postCityid = cookieCityid;
	  } else {
	    postCityid = '0';
	  }
	  return postCityid;
	};

	/**
	 * page-id 处理逻辑
	 * @pageidType
	 * true 则优先从cookie中获取page-id，使用场景 服务端渲染的项目 如m.jiehun.com.cn
	 * false sdk生成一个page-id，并且存入到cookie中
	 *
	 */

	var pageid = function pageid(pageidType, domain) {
	  domain = domain || '.jiehun.com.cn';
	  var pageId = '';
	  if (pageidType) {
	    if (js_cookie.get('page-id')) {
	      pageId = js_cookie.get('page-id');
	      return pageId;
	    } else {
	      pageId = generateUUID();
	      js_cookie.set('page-id', pageId, { expires: 1, path: '/', domain: domain });
	      return pageId;
	    }
	  } else {
	    js_cookie.remove('page-id', { path: '/', domain: domain });
	    pageId = generateUUID();
	    js_cookie.set('page-id', pageId, { expires: 1, path: '/', domain: domain });
	    return pageId;
	  }
	};

	/**
	 * scm-id 活动监测数据处理逻辑 scm_id
	 * 如果该页面接口返回 scm_id 数据且保存在本地存储sessionStorage中。
	 * 判断本地存储中有scm_data数据，则表示该页面需要上报此参数，否则返回null
	 */
	var sessionScmid = window.sessionStorage.getItem('scm_data');
	var urlScmid = getUrlParam('scm_id');

	var scmid = function scmid(id) {
	  var scmData = {};
	  //初始化的时候传入scmid走这里
	  if (id && id > 0) {
	    if (typeof id == 'string' && id.constructor == String) {
	      scmData.scmId = id;
	    } else {
	      scmData.scmId = String(id);
	    }
	  } else if (sessionScmid) {
	    //取sessionStorage中的scm_id走这里
	    scmData = sessionScmid;
	    if (scmData && scmData !== '[object Object]') {
	      window.sessionStorage.removeItem('scm_data');
	      var session_data = JSON.parse(scmData);
	      var scmId = session_data.scm_id ? session_data.scm_id : '';
	      if (typeof scmId == 'string' && scmId.constructor == String) {
	        session_data.scm_id = scmId;
	      } else {
	        session_data.scm_id = String(scmId);
	      }
	      scmData = JSON.parse(JSON.stringify(session_data).replace(/scm_id/, "scmId"));
	    } else {
	      scmData = null;
	    }
	  } else if (urlScmid && urlScmid > 0) {
	    //取URL中的scmid
	    scmData.scmId = urlScmid;
	  }
	  return scmData;
	};

	/**
	 * 实现一个简易的nextTick， 当异步加载元素时，下次 DOM 更新循环结束之后执行延迟回调
	 */

	//回调函数队列
	var callbacks = [];
	//异步锁
	var pending = false;

	//回调函数
	function flushCallbacks() {
	  pending = false;
	  var copies = callbacks.slice(0);
	  callbacks.length = 0;
	  for (var i = 0; i < copies.length; i++) {
	    copies[i]();
	  }
	}
	/**
	 * 
	 * @param {*} cb  回调函数
	 * @param {*} ctx 执行回调函数的上下文环境
	 */
	function nextTick(cb, ctx) {
	  var _resolve = void 0;
	  //将回调函数推入回调队列
	  callbacks.push(function () {
	    if (cb) {
	      try {
	        cb.call(ctx);
	      } catch (e) {
	        console.warn('异步加载dom元素异常');
	      }
	    } else if (_resolve) {
	      _resolve(ctx);
	    }
	  });
	  if (!pending) {
	    pending = true;
	    setTimeout(flushCallbacks, 0);
	  }

	  if (!cb && typeof Promise !== 'undefined') {
	    return new Promise(function (resolve) {
	      _resolve = resolve;
	    });
	  }
	}

	/**
	 * 
	 * @export Tracerpage 封装一个页面抽象类
	 * @class Pages
	 */
	var Tracerpage = function () {
	    function Tracerpage(options) {
	        classCallCheck(this, Tracerpage);

	        this._data = options;

	        this.timeStart = 0; //当前初始化时间
	        this.timeEnd = 0; //离开时间
	        // this.state = 0; //页面状态  enter exit active inactive

	        this.timers = null;
	        this.isleave = false; //页面是否销毁
	        this.Tracer();
	    }

	    createClass(Tracerpage, [{
	        key: 'Tracer',
	        value: function Tracer() {
	            if (window.self != window.top) return;

	            this.page_appear();
	            this.page_disappear();
	            this.page_visibility();
	        }
	        //监听页面加载

	    }, {
	        key: 'page_appear',
	        value: function page_appear() {
	            var _this = this;

	            this.onloadTimes = window.performance.timing.loadEventStart || 0;
	            if (this.onloadTimes) {
	                //已绑定onload事件
	                this.onloads();
	            } else {
	                //无绑定onload事件
	                this.addEvent('load', function () {
	                    _this.onloads();
	                });
	            }
	            window.addEventListener('pageshow', function (event) {
	                _this.onloads();
	            });
	        }
	        //监听页面销毁

	    }, {
	        key: 'page_disappear',
	        value: function page_disappear() {
	            var _this2 = this;

	            this.addEvent('unload', function () {
	                _this2.onbeforeunload();
	            });
	            //beforeunload
	            this.addEvent('beforeunload', function () {
	                _this2.onbeforeunload();
	            });
	            //pagehide 
	            window.addEventListener('pagehide', function () {
	                _this2.onbeforeunload();
	            });
	        }
	        //监听页面状态 

	    }, {
	        key: 'page_visibility',
	        value: function page_visibility() {
	            var _this3 = this;

	            var changeState = void 0;
	            var visibilitychange = void 0;

	            if (typeof document.hidden !== 'undefined') {
	                visibilitychange = 'visibilitychange';
	                changeState = 'visibilityState';
	            } else if (typeof document.mozHidden !== 'undefined') {
	                visibilitychange = 'mozvisibilitychange';
	                changeState = 'mozVisibilityState';
	            } else if (typeof document.msHidden !== 'undefined') {
	                visibilitychange = 'msvisibilitychange';
	                changeState = 'msVisibilityState';
	            } else if (typeof document.webkitHidden !== 'undefined') {
	                visibilitychange = 'webkitvisibilitychange';
	                changeState = 'webkitVisibilityState';
	            }

	            document.addEventListener(visibilitychange, function () {
	                if (document[changeState] == 'hidden') {
	                    _this3.onbeforeunload('visible');
	                }
	                if (document[changeState] == 'visible') {
	                    _this3.onloads('visible');
	                }
	            });
	        }
	    }, {
	        key: 'addEvent',
	        value: function addEvent(type, listener) {
	            if (window.addEventListener) {
	                window.addEventListener(type, listener, false);
	            } else {
	                window.attachEvent('on' + type, listener);
	            }
	        }
	        /**
	         * 页面加载
	        */

	    }, {
	        key: 'onloads',
	        value: function onloads(type) {
	            var _this4 = this;

	            this.timeStart = new Date().getTime().toString();
	            this.isleave = false;

	            this.timers ? clearTimeout(this.timers) : this.timers = null;
	            this.timers = setTimeout(function () {
	                _this4._data.enters(_this4.timeStart, type);
	                clearTimeout(_this4.timers);
	            }, 1000);
	        }
	        /**
	        * 页面关闭
	        */

	    }, {
	        key: 'onbeforeunload',
	        value: function onbeforeunload(type) {
	            this.timeEnd = new Date().getTime().toString();
	            if (!this.isleave) {
	                this.isleave = true;
	                this._data.exits(this.timeEnd, type);
	            }
	        }
	    }]);
	    return Tracerpage;
	}();

	//请求接口
	var fetchData = function fetchData(bodys, headers, url) {
	    var outime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

	    return new Promise(function (resolve) {
	        hAjax({
	            url: url,
	            data: bodys,
	            headers: headers,
	            callback_time: outime,
	            success: function success(res) {
	                resolve(res);
	            },
	            error: function error(err) {
	                resolve(err);
	            }
	        });
	    });
	};

	/** 
	 * 拼装上报的数据结构
	 * @param type 事件类型
	 * @param params 公共参数
	*/
	var assembleDatas = function assembleDatas(type, params, time) {
	    var TYPE = config.ACTIONTYPE.includes(type);
	    var bodys = {
	        cityId: params.city_id,
	        pageName: params.pageName || window.location.href,
	        pageTitle: params.pageTitle || (document.title ? document.title : '中国婚博会'),
	        viewId: params.view_id,
	        authorization: params.authorization,
	        pageId: params.pageId,
	        actionTime: time || new Date().getTime().toString(),
	        actionId: generateUUID(),
	        latitude: params.lat || '0.000000',
	        longitude: params.lng || '0.000000',
	        referer: params.referer || document.referrer ? document.referrer : '',
	        visitCityName: '', // 定位城市name,通过IP地址获取
	        pvId: !params.isPopup ? params.pvid : params.popupPvid,
	        actionType: type,
	        actionName: TYPE ? '' : params.actionName,
	        actionParm: TYPE ? '{}' : params.actionParm,
	        actionValue: TYPE ? '' : params.actionValue,
	        actionPosition: TYPE ? '' : params.actionPosition,
	        timeOnPage: params.timeOnPage || ''
	    };
	    return { bodys: bodys };
	};

	//拼接headers参数
	var assembleHeaders = function assembleHeaders(params) {
	    var header = {
	        'Authorization': params.authorization || getAuthorization(),
	        'city-id': params.city_id,
	        'app-key': params.appkey || 'hunbasha_wap',
	        'jid': params.jid,
	        'client-id': hbhbrowser_min.isApp ? params.client_id : params.jid,
	        'device-id': params.device_id,
	        'app-version': params.app_version,
	        'app-channel': params.app_channel,
	        'page-id': params.pageId
	    };
	    return { header: header };
	};

	//获取登录信息，兼容部分机型登录后事件上报无Authorization的情况
	var getAuthorization = function getAuthorization() {
	    var value = js_cookie.get('Authorization') || js_cookie.get('jhu');
	    if (!value) return '';
	    if (/^dmp/.test(value)) {
	        return value;
	    } else {
	        return 'dmp ' + value;
	    }
	};

	var integrationData = function integrationData(type, action, params, time) {
	    var _assembleDatas = assembleDatas(type, params, time),
	        bodys = _assembleDatas.bodys;

	    var TYPE = config.ACTIONTYPE.includes(type);
	    //此处需要判断是否需要上报scmid参数, 如果需要
	    if (params.scm_data) {
	        var actionParm = action.actionParm ? formatJson(action.actionParm) : {};
	        if (!TYPE) {
	            //页面统计
	            action.actionParm = Object.assign({}, params.scm_data, params.actionParm, actionParm);
	        } else {
	            //事件统计 曝光统计
	            action.actionParm = Object.assign({}, params.scm_data, actionParm);
	        }
	    }    var list = Object.assign(bodys, action);
	    var empty_list = isEmpty(formatJson(list));

	    return empty_list;
	};

	var splicedata = function splicedata(argument) {
	    var obj = {
	        type: '',
	        action: argument.type && argument.type == 'view' ? [] : {},
	        params: '',
	        outime: false,
	        time: ''
	    };
	    for (var i in obj) {
	        obj[i] = argument[i] || obj[i];
	    }
	    var _assembleHeaders = assembleHeaders(obj['params']),
	        header = _assembleHeaders.header;

	    var reportlist = [];
	    return new Promise(function (resolve) {
	        if (obj['type'] === 'view') {
	            for (var _i = 0; _i < obj['action'].length; _i++) {
	                reportlist.push(integrationData(obj['type'], obj['action'][_i], obj['params'], obj['time']));
	            }
	        } else {
	            reportlist.push(integrationData(obj['type'], obj['action'], obj['params'], obj['time']));
	        }

	        var paramsBody = {
	            'data': reportlist
	        };
	        fetchData(paramsBody, header, obj['params'].url, obj['outime']).then(function (res) {
	            resolve(res);
	            if (obj['params'].debug) {
	                //如开启debug，则打印出相关数据
	                debug(reportlist[0], obj['type']);
	            }
	        });
	    });
	};

	//保存上页数据
	var leaves = function leaves(option, endtime, entertime) {
	    var params = new Object();
	    params = Object.assign({}, option);
	    params.leavetime = endtime;
	    params.timeOnPage = (endtime - entertime).toString();
	    params.pageName = window.location.href;
	    params.pageTitle = document.title, params.referer = document.referrer;
	    return params;
	};

	/**
	 * Copyright 2016 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.
	 *
	 *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
	 *
	 */
	(function() {

	// Exit early if we're not running in a browser.
	if (typeof window !== 'object') {
	  return;
	}

	// Exit early if all IntersectionObserver and IntersectionObserverEntry
	// features are natively supported.
	if ('IntersectionObserver' in window &&
	    'IntersectionObserverEntry' in window &&
	    'intersectionRatio' in window.IntersectionObserverEntry.prototype) {

	  // Minimal polyfill for Edge 15's lack of `isIntersecting`
	  // See: https://github.com/w3c/IntersectionObserver/issues/211
	  if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {
	    Object.defineProperty(window.IntersectionObserverEntry.prototype,
	      'isIntersecting', {
	      get: function () {
	        return this.intersectionRatio > 0;
	      }
	    });
	  }
	  return;
	}


	/**
	 * A local reference to the document.
	 */
	var document = window.document;


	/**
	 * Creates the global IntersectionObserverEntry constructor.
	 * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry
	 * @param {Object} entry A dictionary of instance properties.
	 * @constructor
	 */
	function IntersectionObserverEntry(entry) {
	  this.time = entry.time;
	  this.target = entry.target;
	  this.rootBounds = entry.rootBounds;
	  this.boundingClientRect = entry.boundingClientRect;
	  this.intersectionRect = entry.intersectionRect || getEmptyRect();
	  this.isIntersecting = !!entry.intersectionRect;

	  // Calculates the intersection ratio.
	  var targetRect = this.boundingClientRect;
	  var targetArea = targetRect.width * targetRect.height;
	  var intersectionRect = this.intersectionRect;
	  var intersectionArea = intersectionRect.width * intersectionRect.height;

	  // Sets intersection ratio.
	  if (targetArea) {
	    // Round the intersection ratio to avoid floating point math issues:
	    // https://github.com/w3c/IntersectionObserver/issues/324
	    this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));
	  } else {
	    // If area is zero and is intersecting, sets to 1, otherwise to 0
	    this.intersectionRatio = this.isIntersecting ? 1 : 0;
	  }
	}


	/**
	 * Creates the global IntersectionObserver constructor.
	 * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface
	 * @param {Function} callback The function to be invoked after intersection
	 *     changes have queued. The function is not invoked if the queue has
	 *     been emptied by calling the `takeRecords` method.
	 * @param {Object=} opt_options Optional configuration options.
	 * @constructor
	 */
	function IntersectionObserver(callback, opt_options) {

	  var options = opt_options || {};

	  if (typeof callback != 'function') {
	    throw new Error('callback must be a function');
	  }

	  if (options.root && options.root.nodeType != 1) {
	    throw new Error('root must be an Element');
	  }

	  // Binds and throttles `this._checkForIntersections`.
	  this._checkForIntersections = throttle(
	      this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);

	  // Private properties.
	  this._callback = callback;
	  this._observationTargets = [];
	  this._queuedEntries = [];
	  this._rootMarginValues = this._parseRootMargin(options.rootMargin);

	  // Public properties.
	  this.thresholds = this._initThresholds(options.threshold);
	  this.root = options.root || null;
	  this.rootMargin = this._rootMarginValues.map(function(margin) {
	    return margin.value + margin.unit;
	  }).join(' ');
	}


	/**
	 * The minimum interval within which the document will be checked for
	 * intersection changes.
	 */
	IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;


	/**
	 * The frequency in which the polyfill polls for intersection changes.
	 * this can be updated on a per instance basis and must be set prior to
	 * calling `observe` on the first target.
	 */
	IntersectionObserver.prototype.POLL_INTERVAL = null;

	/**
	 * Use a mutation observer on the root element
	 * to detect intersection changes.
	 */
	IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;


	/**
	 * Starts observing a target element for intersection changes based on
	 * the thresholds values.
	 * @param {Element} target The DOM element to observe.
	 */
	IntersectionObserver.prototype.observe = function(target) {
	  var isTargetAlreadyObserved = this._observationTargets.some(function(item) {
	    return item.element == target;
	  });

	  if (isTargetAlreadyObserved) {
	    return;
	  }

	  if (!(target && target.nodeType == 1)) {
	    throw new Error('target must be an Element');
	  }

	  this._registerInstance();
	  this._observationTargets.push({element: target, entry: null});
	  this._monitorIntersections();
	  this._checkForIntersections();
	};


	/**
	 * Stops observing a target element for intersection changes.
	 * @param {Element} target The DOM element to observe.
	 */
	IntersectionObserver.prototype.unobserve = function(target) {
	  this._observationTargets =
	      this._observationTargets.filter(function(item) {

	    return item.element != target;
	  });
	  if (!this._observationTargets.length) {
	    this._unmonitorIntersections();
	    this._unregisterInstance();
	  }
	};


	/**
	 * Stops observing all target elements for intersection changes.
	 */
	IntersectionObserver.prototype.disconnect = function() {
	  this._observationTargets = [];
	  this._unmonitorIntersections();
	  this._unregisterInstance();
	};


	/**
	 * Returns any queue entries that have not yet been reported to the
	 * callback and clears the queue. This can be used in conjunction with the
	 * callback to obtain the absolute most up-to-date intersection information.
	 * @return {Array} The currently queued entries.
	 */
	IntersectionObserver.prototype.takeRecords = function() {
	  var records = this._queuedEntries.slice();
	  this._queuedEntries = [];
	  return records;
	};


	/**
	 * Accepts the threshold value from the user configuration object and
	 * returns a sorted array of unique threshold values. If a value is not
	 * between 0 and 1 and error is thrown.
	 * @private
	 * @param {Array|number=} opt_threshold An optional threshold value or
	 *     a list of threshold values, defaulting to [0].
	 * @return {Array} A sorted list of unique and valid threshold values.
	 */
	IntersectionObserver.prototype._initThresholds = function(opt_threshold) {
	  var threshold = opt_threshold || [0];
	  if (!Array.isArray(threshold)) threshold = [threshold];

	  return threshold.sort().filter(function(t, i, a) {
	    if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {
	      throw new Error('threshold must be a number between 0 and 1 inclusively');
	    }
	    return t !== a[i - 1];
	  });
	};


	/**
	 * Accepts the rootMargin value from the user configuration object
	 * and returns an array of the four margin values as an object containing
	 * the value and unit properties. If any of the values are not properly
	 * formatted or use a unit other than px or %, and error is thrown.
	 * @private
	 * @param {string=} opt_rootMargin An optional rootMargin value,
	 *     defaulting to '0px'.
	 * @return {Array<Object>} An array of margin objects with the keys
	 *     value and unit.
	 */
	IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {
	  var marginString = opt_rootMargin || '0px';
	  var margins = marginString.split(/\s+/).map(function(margin) {
	    var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
	    if (!parts) {
	      throw new Error('rootMargin must be specified in pixels or percent');
	    }
	    return {value: parseFloat(parts[1]), unit: parts[2]};
	  });

	  // Handles shorthand.
	  margins[1] = margins[1] || margins[0];
	  margins[2] = margins[2] || margins[0];
	  margins[3] = margins[3] || margins[1];

	  return margins;
	};


	/**
	 * Starts polling for intersection changes if the polling is not already
	 * happening, and if the page's visibility state is visible.
	 * @private
	 */
	IntersectionObserver.prototype._monitorIntersections = function() {
	  if (!this._monitoringIntersections) {
	    this._monitoringIntersections = true;

	    // If a poll interval is set, use polling instead of listening to
	    // resize and scroll events or DOM mutations.
	    if (this.POLL_INTERVAL) {
	      this._monitoringInterval = setInterval(
	          this._checkForIntersections, this.POLL_INTERVAL);
	    }
	    else {
	      addEvent(window, 'resize', this._checkForIntersections, true);
	      addEvent(document, 'scroll', this._checkForIntersections, true);

	      if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in window) {
	        this._domObserver = new MutationObserver(this._checkForIntersections);
	        this._domObserver.observe(document, {
	          attributes: true,
	          childList: true,
	          characterData: true,
	          subtree: true
	        });
	      }
	    }
	  }
	};


	/**
	 * Stops polling for intersection changes.
	 * @private
	 */
	IntersectionObserver.prototype._unmonitorIntersections = function() {
	  if (this._monitoringIntersections) {
	    this._monitoringIntersections = false;

	    clearInterval(this._monitoringInterval);
	    this._monitoringInterval = null;

	    removeEvent(window, 'resize', this._checkForIntersections, true);
	    removeEvent(document, 'scroll', this._checkForIntersections, true);

	    if (this._domObserver) {
	      this._domObserver.disconnect();
	      this._domObserver = null;
	    }
	  }
	};


	/**
	 * Scans each observation target for intersection changes and adds them
	 * to the internal entries queue. If new entries are found, it
	 * schedules the callback to be invoked.
	 * @private
	 */
	IntersectionObserver.prototype._checkForIntersections = function() {
	  var rootIsInDom = this._rootIsInDom();
	  var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();

	  this._observationTargets.forEach(function(item) {
	    var target = item.element;
	    var targetRect = getBoundingClientRect(target);
	    var rootContainsTarget = this._rootContainsTarget(target);
	    var oldEntry = item.entry;
	    var intersectionRect = rootIsInDom && rootContainsTarget &&
	        this._computeTargetAndRootIntersection(target, rootRect);

	    var newEntry = item.entry = new IntersectionObserverEntry({
	      time: now(),
	      target: target,
	      boundingClientRect: targetRect,
	      rootBounds: rootRect,
	      intersectionRect: intersectionRect
	    });

	    if (!oldEntry) {
	      this._queuedEntries.push(newEntry);
	    } else if (rootIsInDom && rootContainsTarget) {
	      // If the new entry intersection ratio has crossed any of the
	      // thresholds, add a new entry.
	      if (this._hasCrossedThreshold(oldEntry, newEntry)) {
	        this._queuedEntries.push(newEntry);
	      }
	    } else {
	      // If the root is not in the DOM or target is not contained within
	      // root but the previous entry for this target had an intersection,
	      // add a new record indicating removal.
	      if (oldEntry && oldEntry.isIntersecting) {
	        this._queuedEntries.push(newEntry);
	      }
	    }
	  }, this);

	  if (this._queuedEntries.length) {
	    this._callback(this.takeRecords(), this);
	  }
	};


	/**
	 * Accepts a target and root rect computes the intersection between then
	 * following the algorithm in the spec.
	 * TODO(philipwalton): at this time clip-path is not considered.
	 * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo
	 * @param {Element} target The target DOM element
	 * @param {Object} rootRect The bounding rect of the root after being
	 *     expanded by the rootMargin value.
	 * @return {?Object} The final intersection rect object or undefined if no
	 *     intersection is found.
	 * @private
	 */
	IntersectionObserver.prototype._computeTargetAndRootIntersection =
	    function(target, rootRect) {

	  // If the element isn't displayed, an intersection can't happen.
	  if (window.getComputedStyle(target).display == 'none') return;

	  var targetRect = getBoundingClientRect(target);
	  var intersectionRect = targetRect;
	  var parent = getParentNode(target);
	  var atRoot = false;

	  while (!atRoot) {
	    var parentRect = null;
	    var parentComputedStyle = parent.nodeType == 1 ?
	        window.getComputedStyle(parent) : {};

	    // If the parent isn't displayed, an intersection can't happen.
	    if (parentComputedStyle.display == 'none') return;

	    if (parent == this.root || parent == document) {
	      atRoot = true;
	      parentRect = rootRect;
	    } else {
	      // If the element has a non-visible overflow, and it's not the <body>
	      // or <html> element, update the intersection rect.
	      // Note: <body> and <html> cannot be clipped to a rect that's not also
	      // the document rect, so no need to compute a new intersection.
	      if (parent != document.body &&
	          parent != document.documentElement &&
	          parentComputedStyle.overflow != 'visible') {
	        parentRect = getBoundingClientRect(parent);
	      }
	    }

	    // If either of the above conditionals set a new parentRect,
	    // calculate new intersection data.
	    if (parentRect) {
	      intersectionRect = computeRectIntersection(parentRect, intersectionRect);

	      if (!intersectionRect) break;
	    }
	    parent = getParentNode(parent);
	  }
	  return intersectionRect;
	};


	/**
	 * Returns the root rect after being expanded by the rootMargin value.
	 * @return {Object} The expanded root rect.
	 * @private
	 */
	IntersectionObserver.prototype._getRootRect = function() {
	  var rootRect;
	  if (this.root) {
	    rootRect = getBoundingClientRect(this.root);
	  } else {
	    // Use <html>/<body> instead of window since scroll bars affect size.
	    var html = document.documentElement;
	    var body = document.body;
	    rootRect = {
	      top: 0,
	      left: 0,
	      right: html.clientWidth || body.clientWidth,
	      width: html.clientWidth || body.clientWidth,
	      bottom: html.clientHeight || body.clientHeight,
	      height: html.clientHeight || body.clientHeight
	    };
	  }
	  return this._expandRectByRootMargin(rootRect);
	};


	/**
	 * Accepts a rect and expands it by the rootMargin value.
	 * @param {Object} rect The rect object to expand.
	 * @return {Object} The expanded rect.
	 * @private
	 */
	IntersectionObserver.prototype._expandRectByRootMargin = function(rect) {
	  var margins = this._rootMarginValues.map(function(margin, i) {
	    return margin.unit == 'px' ? margin.value :
	        margin.value * (i % 2 ? rect.width : rect.height) / 100;
	  });
	  var newRect = {
	    top: rect.top - margins[0],
	    right: rect.right + margins[1],
	    bottom: rect.bottom + margins[2],
	    left: rect.left - margins[3]
	  };
	  newRect.width = newRect.right - newRect.left;
	  newRect.height = newRect.bottom - newRect.top;

	  return newRect;
	};


	/**
	 * Accepts an old and new entry and returns true if at least one of the
	 * threshold values has been crossed.
	 * @param {?IntersectionObserverEntry} oldEntry The previous entry for a
	 *    particular target element or null if no previous entry exists.
	 * @param {IntersectionObserverEntry} newEntry The current entry for a
	 *    particular target element.
	 * @return {boolean} Returns true if a any threshold has been crossed.
	 * @private
	 */
	IntersectionObserver.prototype._hasCrossedThreshold =
	    function(oldEntry, newEntry) {

	  // To make comparing easier, an entry that has a ratio of 0
	  // but does not actually intersect is given a value of -1
	  var oldRatio = oldEntry && oldEntry.isIntersecting ?
	      oldEntry.intersectionRatio || 0 : -1;
	  var newRatio = newEntry.isIntersecting ?
	      newEntry.intersectionRatio || 0 : -1;

	  // Ignore unchanged ratios
	  if (oldRatio === newRatio) return;

	  for (var i = 0; i < this.thresholds.length; i++) {
	    var threshold = this.thresholds[i];

	    // Return true if an entry matches a threshold or if the new ratio
	    // and the old ratio are on the opposite sides of a threshold.
	    if (threshold == oldRatio || threshold == newRatio ||
	        threshold < oldRatio !== threshold < newRatio) {
	      return true;
	    }
	  }
	};


	/**
	 * Returns whether or not the root element is an element and is in the DOM.
	 * @return {boolean} True if the root element is an element and is in the DOM.
	 * @private
	 */
	IntersectionObserver.prototype._rootIsInDom = function() {
	  return !this.root || containsDeep(document, this.root);
	};


	/**
	 * Returns whether or not the target element is a child of root.
	 * @param {Element} target The target element to check.
	 * @return {boolean} True if the target element is a child of root.
	 * @private
	 */
	IntersectionObserver.prototype._rootContainsTarget = function(target) {
	  return containsDeep(this.root || document, target);
	};


	/**
	 * Adds the instance to the global IntersectionObserver registry if it isn't
	 * already present.
	 * @private
	 */
	IntersectionObserver.prototype._registerInstance = function() {
	};


	/**
	 * Removes the instance from the global IntersectionObserver registry.
	 * @private
	 */
	IntersectionObserver.prototype._unregisterInstance = function() {
	};


	/**
	 * Returns the result of the performance.now() method or null in browsers
	 * that don't support the API.
	 * @return {number} The elapsed time since the page was requested.
	 */
	function now() {
	  return window.performance && performance.now && performance.now();
	}


	/**
	 * Throttles a function and delays its execution, so it's only called at most
	 * once within a given time period.
	 * @param {Function} fn The function to throttle.
	 * @param {number} timeout The amount of time that must pass before the
	 *     function can be called again.
	 * @return {Function} The throttled function.
	 */
	function throttle(fn, timeout) {
	  var timer = null;
	  return function () {
	    if (!timer) {
	      timer = setTimeout(function() {
	        fn();
	        timer = null;
	      }, timeout);
	    }
	  };
	}


	/**
	 * Adds an event handler to a DOM node ensuring cross-browser compatibility.
	 * @param {Node} node The DOM node to add the event handler to.
	 * @param {string} event The event name.
	 * @param {Function} fn The event handler to add.
	 * @param {boolean} opt_useCapture Optionally adds the even to the capture
	 *     phase. Note: this only works in modern browsers.
	 */
	function addEvent(node, event, fn, opt_useCapture) {
	  if (typeof node.addEventListener == 'function') {
	    node.addEventListener(event, fn, opt_useCapture || false);
	  }
	  else if (typeof node.attachEvent == 'function') {
	    node.attachEvent('on' + event, fn);
	  }
	}


	/**
	 * Removes a previously added event handler from a DOM node.
	 * @param {Node} node The DOM node to remove the event handler from.
	 * @param {string} event The event name.
	 * @param {Function} fn The event handler to remove.
	 * @param {boolean} opt_useCapture If the event handler was added with this
	 *     flag set to true, it should be set to true here in order to remove it.
	 */
	function removeEvent(node, event, fn, opt_useCapture) {
	  if (typeof node.removeEventListener == 'function') {
	    node.removeEventListener(event, fn, opt_useCapture || false);
	  }
	  else if (typeof node.detatchEvent == 'function') {
	    node.detatchEvent('on' + event, fn);
	  }
	}


	/**
	 * Returns the intersection between two rect objects.
	 * @param {Object} rect1 The first rect.
	 * @param {Object} rect2 The second rect.
	 * @return {?Object} The intersection rect or undefined if no intersection
	 *     is found.
	 */
	function computeRectIntersection(rect1, rect2) {
	  var top = Math.max(rect1.top, rect2.top);
	  var bottom = Math.min(rect1.bottom, rect2.bottom);
	  var left = Math.max(rect1.left, rect2.left);
	  var right = Math.min(rect1.right, rect2.right);
	  var width = right - left;
	  var height = bottom - top;

	  return (width >= 0 && height >= 0) && {
	    top: top,
	    bottom: bottom,
	    left: left,
	    right: right,
	    width: width,
	    height: height
	  };
	}


	/**
	 * Shims the native getBoundingClientRect for compatibility with older IE.
	 * @param {Element} el The element whose bounding rect to get.
	 * @return {Object} The (possibly shimmed) rect of the element.
	 */
	function getBoundingClientRect(el) {
	  var rect;

	  try {
	    rect = el.getBoundingClientRect();
	  } catch (err) {
	    // Ignore Windows 7 IE11 "Unspecified error"
	    // https://github.com/w3c/IntersectionObserver/pull/205
	  }

	  if (!rect) return getEmptyRect();

	  // Older IE
	  if (!(rect.width && rect.height)) {
	    rect = {
	      top: rect.top,
	      right: rect.right,
	      bottom: rect.bottom,
	      left: rect.left,
	      width: rect.right - rect.left,
	      height: rect.bottom - rect.top
	    };
	  }
	  return rect;
	}


	/**
	 * Returns an empty rect object. An empty rect is returned when an element
	 * is not in the DOM.
	 * @return {Object} The empty rect.
	 */
	function getEmptyRect() {
	  return {
	    top: 0,
	    bottom: 0,
	    left: 0,
	    right: 0,
	    width: 0,
	    height: 0
	  };
	}

	/**
	 * Checks to see if a parent element contains a child element (including inside
	 * shadow DOM).
	 * @param {Node} parent The parent element.
	 * @param {Node} child The child element.
	 * @return {boolean} True if the parent node contains the child node.
	 */
	function containsDeep(parent, child) {
	  var node = child;
	  while (node) {
	    if (node == parent) return true;

	    node = getParentNode(node);
	  }
	  return false;
	}


	/**
	 * Gets the parent node of an element or its host element if the parent node
	 * is a shadow root.
	 * @param {Node} node The node whose parent to get.
	 * @return {Node|null} The parent node or null if no parent exists.
	 */
	function getParentNode(node) {
	  var parent = node.parentNode;

	  if (parent && parent.nodeType == 11 && parent.host) {
	    // If the parent is a shadow root, return the host element.
	    return parent.host;
	  }

	  if (parent && parent.assignedSlot) {
	    // If the parent is distributed in a <slot>, return the parent of a slot.
	    return parent.assignedSlot.parentNode;
	  }

	  return parent;
	}


	// Exposes the constructors globally.
	window.IntersectionObserver = IntersectionObserver;
	window.IntersectionObserverEntry = IntersectionObserverEntry;

	}());

	// polyfill
	// 可以把节流的时间调大一点，默认是100ms
	IntersectionObserver.prototype['THROTTLE_TIMEOUT'] = 50;
	IntersectionObserver.prototype.POLL_INTERVAL = 50; // Time in milliseconds.

	/**
	 * entryList 进入可视区的列表
	 * outList 离开可视区的列表
	 * delay 停留时间
	 * threshold 展现面积
	 * dotDataArr  当前收集 尚未上报的数据 ,也就是已经进入视窗的DOM节点的数据
	 */

	var Exposure = function () {
	    function Exposure() {
	        var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;
	        var threshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
	        var callback = arguments[2];
	        classCallCheck(this, Exposure);

	        this.entryList = {};
	        this.outList = {};
	        this.delay = delay * 1000;
	        this.threshold = threshold;
	        this._timer = 0;
	        this.dotDataArr = [];
	        this.callback = callback;
	        this.init();
	    }

	    createClass(Exposure, [{
	        key: 'init',
	        value: function init() {
	            var self = this;
	            this._observer = new IntersectionObserver(function (entries, observer) {
	                entries.forEach(function (entry) {
	                    var dataAction = entry.target.attributes['data-action'];
	                    // domfreeAction 专题内使用vue.js 的语法，可能会抛出一个错误。兼容写法;
	                    var domfreeAction = entry.target.attributes[':data-action'];
	                    var dataExposure = entry.target.attributes['data-view'];
	                    if (!!!dataAction && !!!domfreeAction) {
	                        console.error('请检查埋点是否设置数据 data-action');
	                        return false;
	                    }
	                    var exposureKey = dataExposure && dataExposure.value;
	                    if (entry.intersectionRatio >= self.threshold) {
	                        //把可见的扔进进入列表
	                        self.entryList[exposureKey] = entry;
	                        if (self.outList[exposureKey]) delete self.outList[exposureKey];
	                    } else {
	                        //不可见的扔进离开列表
	                        self.outList[exposureKey] = entry;
	                        if (self.entryList[exposureKey]) {
	                            // 离开的时候需要判断，之前进入的时间和离开的时间是否超过了delay，如果超过了，则也需要曝光
	                            // if(self.outList[exposureKey].time - self.entryList[exposureKey].time >= self.delay){
	                            //     self._observer.unobserve(self.outList[exposureKey].target);
	                            //     delete self.outList[exposureKey];
	                            // }
	                            delete self.entryList[exposureKey];
	                        }
	                    }
	                });
	                if (self._timer) {
	                    clearTimeout(self._timer);
	                }
	                self._timer = setTimeout(function (list) {
	                    list.forEach(function (name) {
	                        self.dotDataArr.push(self.entryList[name].target);
	                        self._observer.unobserve(self.entryList[name].target);
	                        delete self.entryList[name];
	                    });
	                    self.visibility();
	                }.bind(this, Object.keys(self.entryList)), self.delay);
	            }, {
	                root: null,
	                rootMargin: "0px",
	                threshold: self.threshold // 出现到可视区50%即为 露出
	            });
	        }
	        // 通过全局唯一的Exposure的实例来执行该add方法,将自己添加进观察者中

	    }, {
	        key: 'add',
	        value: function add(entry) {
	            for (var i = 0; i < entry.length; i++) {
	                var dataExposure = entry[i].getAttribute('data-view');
	                if (!!!dataExposure) {
	                    //判读有无data-view，如果没有则加入观察者列表，有则代表已经添加过
	                    //给每个模块添加唯一值
	                    var key = 'view-' + mathRandom();
	                    entry[i] && entry[i].setAttribute('data-view', key);
	                    this._observer && this._observer.observe(entry[i]);
	                }            }        }
	    }, {
	        key: 'visibility',
	        value: function visibility() {
	            var dotDataArr = [].concat(toConsumableArray(this.dotDataArr));
	            this.dotDataArr = [];
	            if (dotDataArr && dotDataArr.length) {
	                this.callback(dotDataArr);
	            }
	        }
	    }]);
	    return Exposure;
	}();

	var _sendpost = function _sendpost(time, type, params) {
	  _postWebData({
	    time: time || '',
	    page: type == 'enter' ? 'page_appear' : 'page_disappear',
	    params: params
	  });
	};

	//页面上报
	var _postWebData = function _postWebData(options) {
	  var time = options.time;
	  var page = options.page;
	  var params = options.params ? Object.assign({}, options.params) : '';
	  if (window.self != window.top) {
	    //如果是iframe引入的页面，禁止重复上报,只上报父页面的。
	    return false;
	  }  if (params) {
	    params.actionName = page;
	    splicedata({ type: 'page', action: {}, params: params, time: time }).then(function () {/**TODO*/});
	  }
	};

	/** 事件上报 -- 根据唯一标识class 去触发上报  */
	var _actionDatas = function _actionDatas(params) {
	  var link = '';
	  // 点击事件唯一标识符  class="action_post_web_data"
	  delegateEvent(window.document, '.action_post_web_data', 'click', function (e) {
	    //元素上面直接埋点的，如果是A标签，则先阻止浏览器的跳转，待接口请求成功，在执行跳转。 如果是其他元素，则正常上报；还有一种特殊情况，层级嵌套，埋点事件是在子级，则需要向上查找，遇到A链接执行阻止的操作。
	    var isTarget_a = function isTarget_a(target) {
	      if (target === null || target.tagName.toUpperCase() === 'BODY') return false;
	      if (target.tagName.toUpperCase() === 'A') {
	        e.preventDefault();
	        link = target.getAttribute('href') ? target.getAttribute('href') : 'javascript:;';
	      } else {
	        if (target.parentNode) {
	          isTarget_a(target.parentNode);
	        }
	      }
	    };
	    isTarget_a(e.target);
	    var action = this.getAttribute('data-action') ? this.getAttribute('data-action') : '{}';
	    action = formatJson(action);
	    splicedata({ type: 'tap', action: action, params: params }).then(function (res) {
	      if (link) {
	        window.location.href = link;
	      }
	    });
	  });
	};

	var exp = null;
	//滚动上报，可视区域上报
	var _viewActionDatas = function _viewActionDatas(params) {
	  var nodes = document.getElementsByClassName('view_post_web_data');
	  exp = new Exposure(params.delay, params.threshold, function (res) {
	    var exposure_list = []; //将同一个视图中的曝光模块一起上报
	    res.forEach(function (element) {
	      //取出数据
	      var attr_action = element.attributes['data-action'].value;
	      attr_action = formatJson(attr_action);
	      exposure_list.push(attr_action);
	    });
	    splicedata({ type: 'view', action: exposure_list, params: params }).then(function (res) {/**TODO*/});
	  });
	  if (nodes.length === 0) {
	    return false;
	  }
	  exp.add([].concat(toConsumableArray(nodes)));
	};

	//手动添加一批异步加载模块的曝光统计
	var _h_actionview = function _h_actionview() {
	  nextTick(function () {
	    var nodes = document.getElementsByClassName('view_post_web_data');
	    if (nodes.length === 0) {
	      return false;
	    }
	    exp && exp.add([].concat(toConsumableArray(nodes)));
	  });
	};

	//阻止符合条件的页面上报，已便自定义参数上报
	/** @param excludeurl 传入屏蔽上报的url关键字数组 */
	var _is_excludeurl = function _is_excludeurl(excludeurl) {
	  var excludeList = [];
	  if (!excludeurl.length) return false;
	  for (var i = 0; i < excludeurl.length; i++) {
	    if (location.href.indexOf(excludeurl[i]) > -1) {
	      excludeList.push(excludeurl[i]);
	    }  }
	  return excludeList.length ? true : false;
	};

	var Postwebdata = function () {
	  function Postwebdata(argument) {
	    var _this = this;

	    classCallCheck(this, Postwebdata);

	    if (typeof argument === 'undefined') {
	      argument = {};
	      console.warn('[注意警告] 数据上报中 appkey 是必填项');
	    } else {
	      if (!argument.appkey) {
	        console.warn('[注意警告] 数据上报中 appkey 是必填项');
	      }
	    }
	    // 基础参数
	    this.options = function () {
	      return {
	        authorization: '', // 用户登录信息
	        city_id: argument.city_id || cityid(), // 城市ID
	        url: argument.url || config.posturl,
	        domain: argument.domain || config.domain,
	        appkey: appkey(argument.appkey), // APP标识
	        pageid_type: argument.pageid_type || false, // pageid的获取方式 如果为true，优先从cookie中获取，反之生成一个pageid并存入cookie中
	        pageId: argument.page_id || pageid(argument.pageid_type, argument.domain), // 页面浏览id
	        lat: '', // 纬度
	        lng: '', // 经度
	        scm_data: scmid(argument.scmid), // 活动监控数据
	        jid: argument.jid || '', // 浏览器id
	        client_id: argument.client_id || '', //跟踪用户标示
	        app_channel: argument.app_channel || '', // 安装(升级)渠道
	        app_version: argument.app_version || '', // APP版本号
	        device_id: argument.device_id || '', // 设备标示符
	        view_id: argument.view_id || '', // 打开APP生成的id
	        debug: argument.debug || false, // 开启debug模式，可以到sessionStorage中查看事件上报信息
	        pvid: generateUUID(),
	        popupPvid: generateUUID(), //弹框的pvid
	        actionName: argument.actionName || '',
	        actionParm: argument.actionParm || '',
	        actionValue: argument.actionValue || '',
	        actionPosition: argument.actionPosition || '',
	        delay: argument.delay || 2,
	        threshold: argument.threshold || 0.5,
	        timeOnPage: '' //页面停留时长
	      };
	    };

	    this.is_singlepage = false; //是否是单页面刷新，即是否执行了_init();
	    this.exclude_url = argument.excludeurl || []; //需要屏蔽的页面
	    this.is_exclude = false;
	    this.entertime = ''; //页面进入时间
	    this.singelPage = { //当前单页面应用临时数据
	      pagename: '',
	      title: ''
	    };

	    _is_excludeurl(this.exclude_url) ? this.is_exclude = true : this.is_exclude = false;
	    this.Tracer = new Tracerpage({
	      params: this.params || {},
	      enters: function enters(startTime, type) {
	        _this._page_appear(startTime, type); //页面日志开始上报 page_appear
	      },
	      exits: function exits(endtime, type) {
	        _this._page_disappear(endtime, type); //页面销毁触发回调 page_disappear 1、发送数据上报  2、将当前数据暂存在localStorage中
	      }
	    });
	  }

	  createClass(Postwebdata, [{
	    key: '_page_appear',
	    value: function _page_appear(time, type) {
	      this.entertime = time;
	      if (!type) {
	        //页面初次加载/刷新
	        this.singelPage.pagename = window.location.href;
	        this.singelPage.title = document.title;

	        this.params = getHead(this.options(), document.cookie);
	        if (this.is_singlepage || this.is_exclude) return;
	        this._integration('tracer', time);
	        this._initEvent('tracer');
	      } else {
	        //页面最小化/切换tab/移动端home
	        this.params.pvid = generateUUID();
	        _sendpost(time, 'enter', this.params);
	      }
	    }
	  }, {
	    key: '_page_disappear',
	    value: function _page_disappear(time, type) {
	      if (!this.params || this.is_singlepage) return;
	      var params = leaves(this.params, time, this.entertime);
	      if (!type) {
	        //页面卸载
	        setStorage('reportstate', params);
	      }
	      _sendpost(params.leavetime, 'exit', params);
	    }
	  }, {
	    key: '_integration',

	    /** 
	     * 页面初始化自执行的事件
	     * @param type 类型 tracer 多页面调用 init 单页面调用
	     *  */
	    value: function _integration(type, time) {
	      _sendpost(time, 'enter', this.params);
	      if (type && type == 'tracer') {
	        if (!getStorage('reportstate')) return false;
	        var reportstate = getStorage('reportstate');
	        _sendpost(reportstate.leavetime, 'exit', reportstate);
	        removeStorage('reportstate');
	      }
	      this.is_singlepage = false;
	      this.is_exclude = false;
	    }
	  }, {
	    key: '_initEvent',

	    //初始化事件上报和曝光统计
	    value: function _initEvent(type) {
	      var _this2 = this;

	      if (type == 'tracer') {
	        nextTick(function () {
	          _actionDatas(_this2.params);
	          _viewActionDatas(_this2.params);
	        });
	      } else {
	        _actionDatas(this.params);
	        setTimeout(function () {
	          _viewActionDatas(_this2.params);
	        }, 400);
	      }
	    }
	  }, {
	    key: '_singleleavepost',

	    /** 单页面离开即上报page_disappear */
	    value: function _singleleavepost() {
	      var leavetime = nowtime();
	      var option = Object.assign({}, this.params);
	      option.pageName = this.singelPage.pagename;
	      option.pageTitle = this.singelPage.title;
	      option.timeOnPage = (leavetime - this.entertime).toString();
	      _sendpost(leavetime, 'exit', option);
	    }
	  }, {
	    key: '_init',

	    /**单页面应用初始化 */
	    value: function _init(argument) {
	      this.is_singlepage = true;
	      this._singleleavepost();
	      this.params = getHead(this.options(), document.cookie);
	      if (isObject(argument)) {
	        this.params = Object.assign(this.params, argument);
	        if (argument.scmid) {
	          this.params.scm_data = scmid(argument.scmid);
	        }
	      }
	      this.singelPage.pagename = window.location.href;
	      this.singelPage.title = document.title;
	      this.entertime = nowtime();
	      if (_is_excludeurl(this.exclude_url)) {
	        return false;
	      }
	      this._integration('init');
	      this._initEvent('init');
	    }
	  }, {
	    key: 'h_actionDatas',

	    /** 事件上报 -- 手动触发事件上报 */
	    value: function h_actionDatas(data) {
	      var that = this;
	      if (!checkType(data)) return false;
	      if (data && data.actionType && data.actionType === 'page') {
	        //兼容处理, h_actionDatas 用于弹框页面上报，更新pvid
	        this.h_actionPopup(data);
	        return false;
	      }      return new Promise(function (resolve) {
	        splicedata({ type: 'tap', action: data, params: that.params, outime: true }).then(function (res) {
	          resolve(res);
	        });
	      });
	    }
	  }, {
	    key: 'h_actionPopup',

	    /** 弹框页面统计  */
	    value: function h_actionPopup(data) {
	      if (!checkType(data)) return false;
	      this.params.popupPvid = generateUUID();
	      this.params.isPopup = true;
	      var that = this;
	      return new Promise(function (resolve) {
	        splicedata({ type: 'page', action: data, params: that.params, outime: true }).then(function (res) {
	          that.params.isPopup = false;
	          resolve(res);
	        });
	      });
	    }
	  }, {
	    key: 'h_popuptap',

	    /** 弹框页面内的点击上报*/
	    value: function h_popuptap(data) {
	      if (!checkType(data)) return false;
	      this.params.isPopup = true;
	      var that = this;
	      return new Promise(function (resolve) {
	        splicedata({ type: 'tap', action: data, params: that.params, outime: true }).then(function (res) {
	          that.params.isPopup = false;
	          resolve(res);
	        });
	      });
	    }
	  }, {
	    key: 'h_actionview',

	    /** 手动添加一批异步加载模块的曝光统计 h_actionview */
	    value: function h_actionview() {
	      _h_actionview();
	    }
	  }, {
	    key: 'h_custompage',

	    //自定义页面数据,如 scmid, actionParm
	    value: function h_custompage(argument) {
	      var _this3 = this;

	      var timer = setTimeout(function () {
	        if (!isObject(argument)) return false;
	        if (!_this3.params) {
	          _this3.params = getHead(_this3.options(), document.cookie);
	        } else {
	          _this3.params = Object.assign(_this3.params, argument);
	        }
	        if (argument.scmid) {
	          _this3.params.scm_data = scmid(argument.scmid);
	        }
	        var types = _this3.is_singlepage ? 'init' : 'tracer';
	        _this3._integration(types, _this3.entertime);
	        _this3._initEvent(types);
	        clearTimeout(timer);
	      }, 1001);
	    }
	  }]);
	  return Postwebdata;
	}();

	return Postwebdata;

})));
